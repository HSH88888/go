<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Smart AI Omok & Baduk</title>
    <style>
        :root {
            --bg-color: #e0e5ec;
            --text-color: #4a4a4a;
            --board-bg: #e3a05b;
            --accent-brown: #5d4037;
            --accent-orange: #ffcc80;
            
            /* Neumorphism Shadows */
            --shadow-light: -9px -9px 16px rgba(255, 255, 255, 0.8);
            --shadow-dark: 9px 9px 16px rgba(163, 177, 198, 0.6);
            --inner-shadow: inset 6px 6px 10px 0 rgba(163, 177, 198, 0.7), 
                            inset -6px -6px 10px 0 rgba(255, 255, 255, 0.8);
            
            --grid-size: 5.2vw;
        }
        @media (min-width: 600px) { :root { --grid-size: 32px; } }

        * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; }

        body {
            margin: 0; padding: 15px 0;
            display: flex; flex-direction: column; align-items: center;
            background-color: var(--bg-color);
            font-family: 'Pretendard', -apple-system, sans-serif;
            color: var(--text-color);
            touch-action: manipulation;
        }

        /* 1. Î©îÏù∏ Ìà¥Î∞î */
        .toolbar {
            width: 95%; max-width: 550px;
            padding: 10px 15px;
            border-radius: 25px;
            background: var(--bg-color);
            box-shadow: var(--shadow-light), var(--shadow-dark);
            display: flex; justify-content: space-between; align-items: center;
            gap: 10px; margin-bottom: 10px;
            position: relative; z-index: 20;
        }

        .mode-switch {
            background: var(--bg-color);
            box-shadow: var(--inner-shadow);
            border-radius: 30px; padding: 4px; display: flex;
        }
        .mode-btn {
            border: none; background: transparent;
            padding: 8px 15px; border-radius: 25px;
            font-weight: bold; color: #888; cursor: pointer; transition: 0.3s;
            font-size: 0.85rem;
        }
        .mode-btn.active {
            background: var(--accent-brown); color: white;
            box-shadow: 2px 2px 5px rgba(0,0,0,0.2);
        }

        .select-box {
            border: none; background: var(--bg-color);
            box-shadow: 3px 3px 6px rgba(163, 177, 198, 0.4), -3px -3px 6px rgba(255,255,255, 0.8);
            border-radius: 12px; padding: 6px 12px;
            font-size: 0.85rem; font-weight: bold; color: #333; outline: none; cursor: pointer;
        }

        .action-group { display: flex; gap: 8px; }
        .action-btn {
            border: none; padding: 8px 12px; border-radius: 12px;
            font-weight: bold; font-size: 0.85rem; cursor: pointer;
            box-shadow: 3px 3px 6px rgba(163, 177, 198, 0.4), -3px -3px 6px rgba(255,255,255, 0.8);
            display: flex; align-items: center; gap: 3px;
        }
        .action-btn:active { box-shadow: var(--inner-shadow); transform: scale(0.95); }
        .btn-undo { background: var(--accent-orange); color: #d84315; }
        .btn-reset { background: var(--bg-color); color: #1565c0; }

        /* 2. AI Î†àÎ≤® Î∞î (Ïà®ÍπÄ/ÌëúÏãú) */
        .level-row {
            width: 90%; max-width: 500px;
            height: 0; overflow: hidden;
            transition: height 0.3s ease, margin 0.3s ease, opacity 0.3s ease;
            opacity: 0; display: flex; justify-content: center; align-items: center;
        }
        .level-row.visible { height: 50px; margin-bottom: 10px; opacity: 1; }

        .level-container {
            display: flex; align-items: center; gap: 10px;
            background: var(--bg-color); padding: 5px 20px; border-radius: 20px;
            box-shadow: var(--inner-shadow);
            font-size: 0.9rem; font-weight: bold; color: #555;
        }

        /* 3. ÏÉÅÌÉú ÌëúÏãúÏ§Ñ */
        .status-bar {
            display: flex; gap: 15px; align-items: center;
            margin-bottom: 15px; font-weight: bold; font-size: 1.1rem;
            flex-wrap: wrap; justify-content: center;
        }
        .omok-rules { display: flex; gap: 10px; font-size: 0.9rem; align-items: center; }
        .checkbox-label {
            display: flex; align-items: center; cursor: pointer;
            background: var(--bg-color); padding: 5px 10px; border-radius: 10px;
            box-shadow: 2px 2px 5px rgba(163, 177, 198, 0.3), -2px -2px 5px rgba(255,255,255,0.8);
        }
        .komi-input {
            width: 45px; border: none; background: var(--bg-color);
            box-shadow: var(--inner-shadow); border-radius: 5px;
            padding: 3px; text-align: center; font-weight: bold; color: #555; margin-left: 5px;
        }

        /* 4. Î∞îÎëëÌåê */
        .board-container {
            padding: 15px; border-radius: 20px;
            background: var(--bg-color);
            box-shadow: var(--shadow-light), var(--shadow-dark);
        }
        .go-board {
            position: relative; background-color: var(--board-bg);
            padding: calc(var(--grid-size) / 2); border-radius: 4px;
            box-shadow: inset 2px 2px 5px rgba(0,0,0,0.2);
        }
        #grid-layer {
            display: grid;
            grid-template-columns: repeat(18, var(--grid-size));
            grid-template-rows: repeat(18, var(--grid-size));
        }
        .grid-cell {
            width: var(--grid-size); height: var(--grid-size);
            border: 0.5px solid rgba(0,0,0,0.5); box-sizing: border-box;
        }
        .star-point {
            position: absolute; width: 6px; height: 6px; background: #000;
            border-radius: 50%; transform: translate(-50%, -50%); pointer-events: none;
        }
        #stone-layer {
            position: absolute; top: 0; left: 0;
            display: grid;
            grid-template-columns: repeat(19, var(--grid-size));
            grid-template-rows: repeat(19, var(--grid-size));
        }
        .intersection {
            width: var(--grid-size); height: var(--grid-size);
            display: flex; justify-content: center; align-items: center; z-index: 10;
        }
        .stone {
            width: 90%; height: 90%; border-radius: 50%; position: relative;
            box-shadow: 2px 2px 4px rgba(0,0,0,0.4);
            transition: transform 0.1s;
        }
        .black { background: radial-gradient(circle at 30% 30%, #555, #000); }
        .white { background: radial-gradient(circle at 30% 30%, #fff, #ddd); }
        .stone.last::after {
            content: ''; position: absolute; top: 50%; left: 50%;
            transform: translate(-50%, -50%); width: 30%; height: 30%;
            background: rgba(231, 76, 60, 0.9); border-radius: 50%; border: 1px solid white;
        }
        .thinking { pointer-events: none; cursor: wait; }
    </style>
</head>
<body>

    <div class="toolbar">
        <div class="mode-switch">
            <button id="btn-omok" class="mode-btn active" onclick="setGameMode('omok')">Ïò§Î™©</button>
            <button id="btn-go" class="mode-btn" onclick="setGameMode('go')">Î∞îÎëë</button>
        </div>

        <div>
            <select id="play-mode" class="select-box" onchange="resetGame()">
                <option value="hvh">ÏÇ¨Îûå vs ÏÇ¨Îûå</option>
                <option value="hva">ÏÇ¨Îûå vs AI</option>
            </select>
        </div>
        
        <div class="action-group">
            <button class="action-btn btn-undo" onclick="undoMove()">‚è™ Î¨¥Î•¥Í∏∞</button>
            <button class="action-btn btn-reset" onclick="resetGame()">üîÑ ÎπÑÏö∞Í∏∞</button>
        </div>
    </div>

    <div id="ai-level-row" class="level-row">
        <div class="level-container">
            <span>üî• AI ÎÇúÏù¥ÎèÑ:</span>
            <select id="ai-level" class="select-box" style="background: transparent; box-shadow: none; padding: 0;">
                <option value="1">Lv.1 (ÏûÖÎ¨∏)</option>
                <option value="2">Lv.2 (Ï¥àÎ≥¥)</option>
                <option value="3">Lv.3 (ÌïòÏàò)</option>
                <option value="4">Lv.4 (Ï§ëÏàò)</option>
                <option value="5">Lv.5 (Î≥¥ÌÜµ)</option>
                <option value="6">Lv.6 (ÏàôÎ†®)</option>
                <option value="7">Lv.7 (Í≥†Ïàò)</option>
                <option value="8">Lv.8 (Ï¥àÍ≥†Ïàò)</option>
                <option value="9" selected>Lv.9 (Ïã†)</option>
            </select>
        </div>
    </div>

    <div class="status-bar">
        <span id="turn-text">ÌùëÎèå Ï∞®Î°Ä</span>
        
        <div id="omok-controls" class="omok-rules">
            <label class="checkbox-label"><input type="checkbox" id="rule33" checked>Ìùë33Á¶Å</label>
            <label class="checkbox-label"><input type="checkbox" id="rule44" checked>Ìùë44Á¶Å</label>
        </div>
        
        <div id="go-score" class="omok-rules" style="display:none; font-size: 0.9rem; color: #444; align-items: center;">
            <span>ÌùëÏßë: <span id="cap-black" style="font-weight:bold">0</span></span>
            <span style="color:#ccc">|</span>
            <span>Î∞±Ïßë: <span id="cap-white" style="font-weight:bold">6.5</span></span>
            <span style="font-size:0.8rem; margin-left:5px;">
                (Îç§:<input type="number" id="komi-val" class="komi-input" value="6.5" step="0.5" onchange="updateUI()">)
            </span>
        </div>
    </div>

    <div class="board-container">
        <div class="go-board" id="board-area">
            <div id="grid-layer"></div>
            <div id="stone-layer"></div>
        </div>
    </div>

    <script>
        const size = 19;
        let board = [];
        let currentPlayer = 'black';
        let gameMode = 'omok'; 
        let playMode = 'hvh'; 
        let historyStack = [];
        let captured = { black: 0, white: 0 };
        let isGameOver = false;
        let koPos = null;
        let isAiThinking = false;
        let lastMovePos = null; // ÎßàÏßÄÎßâ Ïàò Ï¢åÌëú Ï†ÄÏû• (AI ÌåêÎã®Ïö©)

        const gridLayer = document.getElementById('grid-layer');
        const stoneLayer = document.getElementById('stone-layer');
        const turnText = document.getElementById('turn-text');
        const komiInput = document.getElementById('komi-val');
        const playModeSelect = document.getElementById('play-mode');
        const aiLevelSelect = document.getElementById('ai-level');
        const aiLevelRow = document.getElementById('ai-level-row');
        const boardArea = document.getElementById('board-area');

        function init() {
            gridLayer.innerHTML = '';
            stoneLayer.innerHTML = '';
            for (let i = 0; i < 18 * 18; i++) {
                const cell = document.createElement('div');
                cell.className = 'grid-cell';
                gridLayer.appendChild(cell);
            }
            const stars = [3, 9, 15];
            stars.forEach(y => stars.forEach(x => {
                const star = document.createElement('div');
                star.className = 'star-point';
                star.style.top = `calc(${y} * var(--grid-size) + var(--grid-size)/2)`;
                star.style.left = `calc(${x} * var(--grid-size) + var(--grid-size)/2)`;
                gridLayer.appendChild(star);
            }));
            for (let y = 0; y < size; y++) {
                for (let x = 0; x < size; x++) {
                    const inter = document.createElement('div');
                    inter.className = 'intersection';
                    inter.id = `cell-${y}-${x}`;
                    inter.onclick = (e) => { e.preventDefault(); handleMove(y, x); };
                    stoneLayer.appendChild(inter);
                }
            }
            resetData();
        }

        function resetData() {
            board = Array.from(Array(size), () => Array(size).fill(null));
            historyStack = [];
            captured = { black: 0, white: 0 };
            currentPlayer = 'black';
            isGameOver = false;
            koPos = null;
            lastMovePos = null;
            isAiThinking = false;
            boardArea.classList.remove('thinking');
            renderBoard(); 
            updateUI();
        }

        function setGameMode(mode) {
            if(historyStack.length > 0 && !confirm("Î™®Îìú Î≥ÄÍ≤Ω Ïãú Í≤åÏûÑÏù¥ Ï¥àÍ∏∞ÌôîÎê©ÎãàÎã§.")) return;
            gameMode = mode;
            document.querySelectorAll('.mode-btn').forEach(b => b.classList.remove('active'));
            document.getElementById(`btn-${mode}`).classList.add('active');
            document.getElementById('omok-controls').style.display = (mode === 'omok') ? 'flex' : 'none';
            document.getElementById('go-score').style.display = (mode === 'go') ? 'flex' : 'none';
            resetGame();
        }

        function handleMove(y, x) {
            if (isGameOver || board[y][x] || isAiThinking) return;

            if (executeMove(y, x)) {
                if (!isGameOver && playMode === 'hva' && currentPlayer === 'white') {
                    isAiThinking = true;
                    boardArea.classList.add('thinking');
                    setTimeout(() => {
                        aiMove();
                        isAiThinking = false;
                        boardArea.classList.remove('thinking');
                    }, 200);
                }
            }
        }

        function executeMove(y, x) {
            const snapshot = {
                board: JSON.parse(JSON.stringify(board)),
                currentPlayer,
                captured: {...captured},
                koPos,
                lastMovePos
            };

            let success = false;
            if (gameMode === 'omok') success = processOmok(y, x);
            else success = processGo(y, x);

            if (success) {
                lastMovePos = {y, x}; // ÎßàÏßÄÎßâ Ï∞©Ïàò Ï†ÄÏû•
                historyStack.push({ ...snapshot, move: {y, x} });
                playSound();
                renderBoard(y, x); 
                
                if (gameMode === 'omok' && checkOmokWin(y, x)) {
                    setTimeout(() => alert(`${currentPlayer==='black'?'Ìùë':'Î∞±'} ÏäπÎ¶¨!`), 20);
                    isGameOver = true;
                    return true;
                }
                
                currentPlayer = (currentPlayer === 'black') ? 'white' : 'black';
                updateUI();
                return true;
            }
            return false;
        }

        function aiMove() {
            if (isGameOver) return;
            const level = parseInt(aiLevelSelect.value);
            let bestMove = (gameMode === 'go') ? getGoWeightedMove(level) : getOmokWeightedMove(level);
            
            if (bestMove) executeMove(bestMove.y, bestMove.x);
            else alert("AIÍ∞Ä Îëò Í≥≥Ïù¥ ÏóÜÏäµÎãàÎã§.");
        }

        // --- Improved Go AI Logic ---
        function getGoWeightedMove(level) {
            let maxScore = -Infinity;
            let moves = [];
            const center = Math.floor(size / 2);
            let errorRate = Math.max(0, 10 - level) * 0.1; // Î†àÎ≤®Ïù¥ ÎÜíÏùÑÏàòÎ°ù Ïã§Ïàò Ï§ÑÏñ¥Îì¶

            for(let y=0; y<size; y++) {
                for(let x=0; x<size; x++) {
                    if(!board[y][x]) {
                        // 0. ÏûêÏÇ¥Ïàò & Ìå® Ï≤¥ÌÅ¨ (ÌïÑÏàò)
                        if (isSuicideOrKo(y, x, 'white')) continue;

                        let score = 0;

                        // 1. Îã®Ïàò(Atari) Ï≤¥ÌÅ¨: ÎÇ¥ Îèå ÏÇ¥Î¶¨Í∏∞ & ÏÉÅÎåÄ Îèå Ïû°Í∏∞
                        const atariScore = checkAtariScore(y, x, 'white');
                        score += atariScore;

                        // 2. ÏúÑÏπò Ï†êÏàò (3ÏÑ†, 4ÏÑ† ÏÑ†Ìò∏ / 1ÏÑ†, 2ÏÑ† Í∏∞Ìîº)
                        const lineY = Math.min(y, size - 1 - y);
                        const lineX = Math.min(x, size - 1 - x);
                        const minLine = Math.min(lineY, lineX);
                        
                        if (minLine === 2 || minLine === 3) score += 20; // 3~4ÏÑ† (Good)
                        else if (minLine === 0) score -= 50; // 1ÏÑ† (Bad)
                        else if (minLine === 1) score -= 10; // 2ÏÑ† (Not good early)

                        // 3. ÌôîÏ†ê Î≥¥ÎÑàÏä§ (Ï¥àÎ∞ò Ìè¨ÏÑù)
                        if ((lineY === 3 && lineX === 3) || (lineY === 3 && lineX === 9) || (lineY === 9 && lineX === 3)) {
                             score += 15;
                        }

                        // 4. Ï†ÑÌà¨ ÏßÄÌñ• (ÎßàÏßÄÎßâ Ïàò Í∑ºÏ≤òÏóê ÎëêÍ∏∞)
                        if (lastMovePos) {
                            const dist = Math.abs(y - lastMovePos.y) + Math.abs(x - lastMovePos.x);
                            if (dist <= 3) score += 10; // Í∑ºÏ≤òÎ©¥ Î≥¥ÎÑàÏä§
                        }

                        // 5. ÎûúÎç§ ÎÖ∏Ïù¥Ï¶à (Î†àÎ≤®Ïóê Îî∞Îùº Îã§Î¶Ñ)
                        score += Math.random() * (50 * errorRate);

                        if (score > maxScore) {
                            maxScore = score;
                            moves = [{y, x}];
                        } else if (score === maxScore) {
                            moves.push({y, x});
                        }
                    }
                }
            }
            return moves.length > 0 ? moves[Math.floor(Math.random() * moves.length)] : null;
        }

        // 1. ÏûêÏÇ¥Ïàò ÎòêÎäî Ìå®Ïù∏ÏßÄ ÌôïÏù∏
        function isSuicideOrKo(y, x, color) {
             if (koPos && koPos.y === y && koPos.x === x) return true;
             
             // Í∞ÄÏÉÅ Ï∞©Ïàò
             board[y][x] = color;
             const opponent = (color === 'black') ? 'white' : 'black';
             
             // ÏÉÅÎåÄ Îèå Îî∞ÎÇ¥ÎäîÏßÄ ÌôïÏù∏
             let captures = 0;
             [[0,1],[0,-1],[1,0],[-1,0]].forEach(([dy, dx]) => {
                const ny=y+dy, nx=x+dx;
                if(ny>=0 && ny<size && nx>=0 && nx<size && board[ny][nx]===opponent) {
                    const g = getGroup(ny, nx, opponent);
                    if (getLiberties(g) === 0) captures++;
                }
             });

             // ÎÇ¥ ÌôúÎ°ú ÌôïÏù∏
             const myGroup = getGroup(y, x, color);
             const liberties = getLiberties(myGroup);
             
             board[y][x] = null; // ÏõêÏÉÅÎ≥µÍµ¨

             // Îî∞ÎÇ¥Îäî ÎèåÏù¥ ÏóÜÍ≥†, ÎÇ¥ ÌôúÎ°úÍ∞Ä 0Ïù¥Î©¥ ÏûêÏÇ¥Ïàò
             if (captures === 0 && liberties === 0) return true;
             return false;
        }

        // 2. Îã®Ïàò ÏÉÅÌô© Ï†êÏàò Í≥ÑÏÇ∞
        function checkAtariScore(y, x, color) {
            let score = 0;
            const opponent = (color === 'black') ? 'white' : 'black';
            
            board[y][x] = color; // Í∞ÄÏÉÅ Ï∞©Ïàò

            // A. ÏÉÅÎåÄÎ•º Ïû°ÏùÑ Ïàò ÏûàÎäîÍ∞Ä? (ÏÉÅÎåÄ ÌôúÎ°ú 0)
            [[0,1],[0,-1],[1,0],[-1,0]].forEach(([dy, dx]) => {
                const ny=y+dy, nx=x+dx;
                if(ny>=0 && ny<size && nx>=0 && nx<size && board[ny][nx]===opponent) {
                    const g = getGroup(ny, nx, opponent);
                    if (getLiberties(g) === 0) score += 1000; // ÎåÄÎ∞ï
                    else if (getLiberties(g) === 1) score += 100; // Îã®Ïàò Ïπ®
                }
            });

            // B. ÎÇ¥ ÎèåÏù¥ ÏúÑÌóòÌïúÍ∞Ä? (ÎÇ¥ ÌôúÎ°ú 1Í∞ú = ÏûáÏßÄ ÏïäÏúºÎ©¥ Ï£ΩÏùå) -> Ïù¥Í±¥ Î∞©Ïñ¥ Î°úÏßÅ
            // ÌòÑÏû¨ ÎÇ¥Í∞Ä Îë¨ÏÑú ÌôúÎ°úÍ∞Ä 1Í∞úÍ∞Ä ÎêòÎ©¥ Ïïà Ï¢ãÏùÄ Ïàò (Îã®, ÏÉÅÎåÄÎ•º Ïû°ÏúºÎ©¥ OK)
            const myGroup = getGroup(y, x, color);
            const myLib = getLiberties(myGroup);
            if (myLib === 1) score -= 200; // Ïä§Ïä§Î°ú Îã®ÏàòÎê® (Bad)
            if (myLib >= 4) score += 10; // ÌäºÌäºÌï®

            board[y][x] = null; // Î≥µÍµ¨
            return score;
        }

        function getOmokWeightedMove(level) {
            let maxScore = -Infinity;
            let moves = [];
            const center = Math.floor(size / 2);
            let errorRate = 0; let defenseWeight = 1.0; 
            
            if (level <= 3) { errorRate = 0.6; defenseWeight = 0.5; }
            else if (level <= 6) { errorRate = 0.2; defenseWeight = 0.9; }
            else { errorRate = 0.0; defenseWeight = 1.5; } 

            for(let y=0; y<size; y++) {
                for(let x=0; x<size; x++) {
                    if(!board[y][x]) {
                        let attackScore = evaluatePos(y, x, 'white');
                        let defenseScore = evaluatePos(y, x, 'black');
                        if (level >= 8 && defenseScore >= 5000) defenseScore *= 2.0;
                        const dist = Math.abs(y - center) + Math.abs(x - center);
                        const centerBonus = (size - dist); 
                        let noise = Math.random() * (1000 * errorRate);
                        let totalScore = attackScore + (defenseScore * defenseWeight) + centerBonus + noise;
                        if (level <= 3 && Math.random() < 0.3) totalScore = 0;

                        if (totalScore > maxScore) {
                            maxScore = totalScore;
                            moves = [{y, x}];
                        } else if (totalScore === maxScore) {
                            moves.push({y, x});
                        }
                    }
                }
            }
            return moves.length > 0 ? moves[Math.floor(Math.random() * moves.length)] : null;
        }

        function evaluatePos(y, x, color) {
            const dirs = [[0,1],[1,0],[1,1],[1,-1]];
            let score = 0;
            dirs.forEach(([dy, dx]) => {
                let count = 1; let blocked = 0;
                let i=1; while(board[y+dy*i]?.[x+dx*i] === color) { count++; i++; }
                if(board[y+dy*i]?.[x+dx*i] !== null) blocked++;
                let j=1; while(board[y-dy*j]?.[x-dx*j] === color) { count++; j++; }
                if(board[y-dy*j]?.[x-dx*j] !== null) blocked++;
                if (count >= 5) score += 200000;
                else if (count === 4) score += (blocked === 0) ? 50000 : 2500;
                else if (count === 3) score += (blocked === 0) ? 3000 : 200;
                else if (count === 2 && blocked === 0) score += 50;
            });
            return score;
        }

        // --- Rules ---
        function processOmok(y, x) {
            if (currentPlayer === 'black') {
                const r33 = document.getElementById('rule33').checked;
                const r44 = document.getElementById('rule44').checked;
                if (r33 && checkForbidden(y, x, 3)) { alert("3-3 Í∏àÏàò!"); return false; }
                if (r44 && checkForbidden(y, x, 4)) { alert("4-4 Í∏àÏàò!"); return false; }
            }
            board[y][x] = currentPlayer;
            return true;
        }
        function checkForbidden(y, x, k) {
            board[y][x] = 'black';
            let cnt = 0;
            const dirs = [[0,1],[1,0],[1,1],[1,-1]];
            for(let [dy, dx] of dirs) {
                let c = 1;
                let i=1; while(board[y+dy*i]?.[x+dx*i] === 'black') { c++; i++; }
                let j=1; while(board[y-dy*j]?.[x-dx*j] === 'black') { c++; j++; }
                if(c === k) cnt++;
            }
            board[y][x] = null;
            return cnt >= 2;
        }
        function checkOmokWin(y, x) {
            const c = board[y][x];
            const dirs = [[0,1],[1,0],[1,1],[1,-1]];
            for(let [dy, dx] of dirs) {
                let count = 1;
                let i=1; while(board[y+dy*i]?.[x+dx*i] === c) { count++; i++; }
                i=1; while(board[y-dy*i]?.[x-dx*i] === c) { count++; i++; }
                if(count >= 5) return true;
            }
            return false;
        }
        function processGo(y, x) {
            if (koPos && koPos.y === y && koPos.x === x) {
                if(playMode === 'hvh') alert("Ìå®(Ko)");
                return false;
            }
            const opponent = (currentPlayer === 'black') ? 'white' : 'black';
            board[y][x] = currentPlayer;
            let capturedStones = [];
            [[0,1],[0,-1],[1,0],[-1,0]].forEach(([dy, dx]) => {
                const ny=y+dy, nx=x+dx;
                if(ny>=0 && ny<size && nx>=0 && nx<size && board[ny][nx]===opponent) {
                    const group = getGroup(ny, nx, opponent);
                    if(getLiberties(group) === 0) capturedStones.push(...group);
                }
            });
            const myGroup = getGroup(y, x, currentPlayer);
            if(capturedStones.length === 0 && getLiberties(myGroup) === 0) {
                board[y][x] = null;
                if(playMode === 'hvh') alert("ÏûêÏÇ¥Ïàò Í∏àÏßÄ");
                return false;
            }
            capturedStones.forEach(p => board[p.y][p.x] = null);
            captured[currentPlayer] += capturedStones.length;
            if (capturedStones.length === 1 && myGroup.length === 1 && getLiberties(myGroup) === 1) koPos = capturedStones[0];
            else koPos = null;
            return true;
        }
        function getGroup(y, x, color) {
            let g = [], visited = new Set(), stack = [{y, x}];
            visited.add(`${y},${x}`);
            while(stack.length) {
                let cur = stack.pop(); g.push(cur);
                [[0,1],[0,-1],[1,0],[-1,0]].forEach(([dy, dx]) => {
                    let ny=cur.y+dy, nx=cur.x+dx;
                    if(ny>=0 && ny<size && nx>=0 && nx<size && board[ny][nx]===color && !visited.has(`${ny},${nx}`)) {
                        visited.add(`${ny},${nx}`); stack.push({y:ny, x:nx});
                    }
                });
            }
            return g;
        }
        function getLiberties(group) {
            let lib = new Set();
            group.forEach(p => {
                [[0,1],[0,-1],[1,0],[-1,0]].forEach(([dy, dx]) => {
                    let ny=p.y+dy, nx=p.x+dx;
                    if(ny>=0 && ny<size && nx>=0 && nx<size && board[ny][nx]===null) lib.add(`${ny},${nx}`);
                });
            });
            return lib.size;
        }

        function undoMove() {
            if(historyStack.length === 0) return;
            let steps = (playMode === 'hva' && historyStack.length >= 2) ? 2 : 1;
            for(let i=0; i<steps; i++) {
                const prev = historyStack.pop();
                board = prev.board;
                currentPlayer = prev.currentPlayer;
                captured = prev.captured;
                koPos = prev.koPos;
                lastMovePos = prev.lastMovePos;
            }
            isGameOver = false;
            let lastMove = historyStack.length > 0 ? historyStack[historyStack.length-1].move : {y:-1, x:-1};
            renderBoard(lastMove.y, lastMove.x);
            updateUI();
        }

        function renderBoard(lastY = -1, lastX = -1) {
            for(let y=0; y<size; y++) {
                for(let x=0; x<size; x++) {
                    const cell = document.getElementById(`cell-${y}-${x}`);
                    const stoneVal = board[y][x];
                    const existingStone = cell.querySelector('.stone');
                    
                    if (stoneVal) {
                        if (!existingStone) {
                            addStoneToCell(cell, stoneVal, y===lastY && x===lastX);
                        } else {
                            const isBlack = existingStone.classList.contains('black');
                            const shouldBeBlack = (stoneVal === 'black');
                            const isLast = existingStone.classList.contains('last');
                            const shouldBeLast = (y===lastY && x===lastX);
                            if (isBlack !== shouldBeBlack || isLast !== shouldBeLast) {
                                cell.innerHTML = '';
                                addStoneToCell(cell, stoneVal, shouldBeLast);
                            }
                        }
                    } else {
                        if (existingStone) cell.innerHTML = '';
                    }
                }
            }
        }

        function addStoneToCell(cell, color, isLast) {
            const s = document.createElement('div');
            s.className = `stone ${color}`;
            if (isLast) s.classList.add('last');
            cell.appendChild(s);
        }

        function updateUI() {
            playModeSelect.value = playMode;
            playMode = playModeSelect.value;
            
            // AI Î†àÎ≤® Î∞î ÌëúÏãú (Ïä¨ÎùºÏù¥Îìú Ïï†ÎãàÎ©îÏù¥ÏÖò)
            if (playMode === 'hva') aiLevelRow.classList.add('visible');
            else aiLevelRow.classList.remove('visible');
            
            turnText.innerText = `${currentPlayer === 'black' ? 'ÌùëÎèå' : 'Î∞±Îèå'} Ï∞®Î°Ä`;
            document.getElementById('cap-black').innerText = captured.white;
            const komi = parseFloat(komiInput.value) || 0;
            document.getElementById('cap-white').innerText = captured.black + komi;
        }

        function resetGame() { 
            playMode = playModeSelect.value;
            resetData(); 
        }

        function playSound() {
            try {
                const ctx = new (window.AudioContext || window.webkitAudioContext)();
                const osc = ctx.createOscillator();
                const gain = ctx.createGain();
                osc.frequency.setValueAtTime(600, ctx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(100, ctx.currentTime + 0.1);
                gain.gain.setValueAtTime(0.1, ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.1);
                osc.connect(gain); gain.connect(ctx.destination);
                osc.start(); osc.stop(ctx.currentTime + 0.1);
            } catch(e) {}
        }

        window.onload = init;
    </script>
</body>
</html>
